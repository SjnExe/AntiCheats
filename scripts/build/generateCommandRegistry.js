// @ts-check
// Simple Node.js script to generate AntiCheatsBP/scripts/core/commandRegistry.js

import fs from 'fs';
import path from 'path';

const commandsDir = path.join('AntiCheatsBP', 'scripts', 'commands');
const commandRegistryFile = path.join('AntiCheatsBP', 'scripts', 'core', 'commandRegistry.js');
const projectRootDir = process.cwd(); // Assuming script is run from project root

const commandsPath = path.join(projectRootDir, commandsDir);
const registryPath = path.join(projectRootDir, commandRegistryFile);

console.log(`[BuildScript] Generating command registry...`);
console.log(`[BuildScript] Commands directory: ${commandsPath}`);
console.log(`[BuildScript] Output file: ${registryPath}`);

try {
    const files = fs.readdirSync(commandsPath);
    const commandFiles = files.filter(file => file.endsWith('.js'));

    if (commandFiles.length === 0) {
        console.warn('[BuildScript] No command files found in commands directory. Registry will be empty.');
    } else {
        console.log(`[BuildScript] Found ${commandFiles.length} command files.`);
    }

    const imports = [];
    const moduleReferences = [];

    commandFiles.forEach(file => {
        const commandName = path.basename(file, '.js');
        // Sanitize commandName if it includes characters not valid for variable names, though unlikely for filenames.
        // For example, if a filename was 'my-command.js', moduleAlias would be 'myCommandCmd'.
        // Current filenames are simple (e.g., 'addrank.js'), so direct camelCase or simple suffix is fine.
        const moduleAlias = `${commandName}Cmd`;

        imports.push(`import * as ${moduleAlias} from '../commands/${file}';`);
        moduleReferences.push(moduleAlias);
    });

    const fileHeader = `/**
 * @file Central registry for all command modules. This file imports all individual command
 * files and exports them as an array to be used by the commandManager.
 *
 * THIS FILE IS AUTO-GENERATED BY 'scripts/build/generateCommandRegistry.js'.
 * DO NOT EDIT THIS FILE MANUALLY.
 */
`;

    const typeImportComment = `
// Ensure JSDoc type import path is correct based on its location relative to types.js
// If commandRegistry.js is in 'core/', and types.js is in root 'scripts/', path is '../types.js'
// If commandRegistry.js is in 'commands/', and types.js is in root 'scripts/', path is '../../types.js'
// Current: core/commandRegistry.js -> ../types.js is correct.
`;

    const content = `${fileHeader}
// Import all command modules
${imports.join('\n')}

/**
 * Array containing all registered command modules.
 * Each module is expected to export a \`definition\` object (conforming to \`CommandDefinition\` type)
 * and an \`execute\` function.
 */
/** @type {Array<import('../types.js').CommandModule>} */
export const commandModules = [
    ${moduleReferences.map(ref => ref).join(',\n    ')}
];
${typeImportComment}
`;

    fs.writeFileSync(registryPath, content);
    console.log(`[BuildScript] Successfully generated ${commandRegistryFile}`);

} catch (error) {
    console.error(`[BuildScript] Error generating command registry:`, error);
    process.exit(1); // Exit with error code
}
